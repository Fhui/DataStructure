# DataStructure
数据结构

## 0.时间复杂度与空间复杂度

* 时间复杂度  
    * 什么是时间复杂度
    * 如何计算时间复杂度
* 空间复杂度  
    * 什么是空间复杂度
    * 如何计算空间复杂度

## 1.数组

* 什么是数组
* 在Java中的体现
* 利与弊

## 2.链表

* 什么是链表
* 链表的分类
    * 单向链表
    * 双向链表
    * 单向循环链表
    * 双向循环链表
* 链表的操作
    * 添加（添加首部，添加尾部，插入中间）
    * 删除（删除首部，删除尾部，删除中间）
* 在Java中的体现
* 衍生其他数据结构  
  * 堆栈
  * 队列
* 实际应用场景
* 利与弊  

## (总结)数组&&链表的区别
* 内存连续性
* 时间复杂度与空间复杂
* 业务数据的处理
    * 插入
    * 查找


## 3.堆栈 

* 什么是堆栈 
* 实际应用场景
  * LRU缓存 
  * 解释计算器
  * 浏览器进退网页
* 在Java中的体现

## 4.队列 

* 什么是堆栈 
* 实际应用场景
* 在Java中的体现

## (总结)堆栈 &&队列的区别

## 5.递归

* 什么是递归
    * "递"
    * "归"
* 什么样的问题可以用递归解决
    * 大问题划小问题
    * 所有小问题解决的方式是一致的
    * 存在结束条件
* 实际应用场景
     * 走楼梯问题
     * 生兔子问题
* 利与弊

## 6.排序入门

* 基本概念  
  * 满有序度、有序度、逆序度
  * 原地排序
  * 稳定性
* 排序算法的判断标准  
  * 执行效率
      * 时间复杂度(最好情况、最坏情况、平均情况、系数、常数、低阶)
      * 比较&交换的次数
  * 内存消耗
  * 稳定性

## 7.冒泡排序

* 基本原理
* 示例流程
* 实现代码
* 执行效率  


    最差情况O(n^2) 
    最好情况O(n^2)
    平均情况O(n^2)

* 内存消耗
 

    O(n)


* 稳定性  


    稳定的,取无序的首下标与插入有序的末端

## 8.插入排序

* 基本原理
* 示例流程
* 实现代码
* 执行效率  


    最差情况O(n^2) 
    最好情况O(n^2)
    平均情况O(n^2)

* 内存消耗
 

    O(n)


* 稳定性  


    稳定的,取无序的首下标与插入有序的末端

## 9.选择排序

* 基本原理
* 示例流程
* 实现代码
* 判断标准  
* 执行效率  


    最差情况O(n^2) 
    最好情况O(n^2)
    平均情况O(n^2)

* 内存消耗
 

    O(n)


* 稳定性  


    不稳定的,取最小元素与有序的末端进行交换


## 10.归并排序

* 基本原理
* 示例流程
* 实现代码
* 执行效率  


    最差情况O(n(logn)) 
    最好情况O(n(logn))
    平均情况O(n(logn))

* 内存消耗
 

    是O(n)，为什么不是n(logn)?
    因为同一时间内只能执行一次，并释放临时内存


* 稳定性  


    稳定的


## 11.快速排序

* 基本原理  

    * 整体思想  
        * A.将一段数据以基准数据为比较，不断分为两部分，左边小于基准数据，右边大于或等于基准数据，  
        * B.将左边部分重复A操作，将右边部分重复A操作，  
        * C.经过不断的划分排序，最终实现有序
    * 划分排序  
        * 若A的长度为r,则取坐标为[0，r]，  
        * 1.采用分治的思想，将    
        * 2.以尾部数据A[r]为基准数据，  
        * 3.以i坐标为替换坐标，j坐标为遍历数据坐标，每遍历一次，j=j+1，  
        * 4.若A[j]小于A[r]，与A[i]数据替换，每替换一次i=i+1，  
        * 5.当j遍历到r-1时，交换A[i]与A[r]，  
        * 6.最终实现坐标i左边的数据都是小于A[r]的，反之右边都是大于或等于A[r]的


* 示例流程  
    * 原始数据为：A={3,1,5,2,6,4}，以i坐标为替换坐标，j坐标为遍历数据坐标，初使化数据i=j=0,r=5;
    * 步骤一，比较A[j]以及A[r],即比较3和4,符合条件，将i,j数据替换，即A[0]与A[0]替换，  将i坐标，j坐标同时加1，即i=j=1;
        * {3,1,5,2,6,4}
    * 步骤二，比较A[j]以及A[r],即比较1和4,符合条件，将i,j数据替换，即A[1]与A[1]替换，将i坐标，j坐标同时加1，即i=j=2;
        * {3,1,5,2,6,4}  
    * 步骤三，比较A[j]以及A[r],即比较5和4,不符合条件，将j坐标加1，i坐标不变，即i=2，j=3;
        * {3,1,5,2,6,4}    
    * 步骤四，比较A[j]以及A[r],即比较2和4,符合条件，将i,j数据替换，即A[2]与A[3]替换，将i坐标，j坐标同时加1，即i=3，j=4;
        * {3,1,2,5,6,4} 
    * 步骤五，比较A[j]以及A[r],即比较6和4,不符合条件，将j坐标加1，i坐标不变，即i=3，j=5;
        * {3,1,2,5,6,4} 
    * 步骤六,比较结束,将i,r数据替换, 实现第一次的划分排序
        * {3,1,2,4,6,5} 
    * 步骤七,将4左边的数据重复以上步骤, 实现第二次的划分排序
        * {3,1,2,4,6,5} 
        * {1,3,2,4,6,5} 
        * {1,2,3,4,6,5} 
    * 步骤八,将4左边的数据重复以上步骤, 实现第三次的划分排序
        * {1,2,3,4,5,6} 
    * 结束
    

* 实现代码    

` ` ` Java
    //快速排序  
    public static void quickSort(int[] arr){   
      qsort(arr, 0, arr.length-1);  
    }  
    //递归   
    private static void qsort(int[] arr, int i, int r){  
        if (low < high){  
            //将数组分为两部分  
            int pivot=partition(arr, i, r);         
            //递归排序左子数组  
            qsort(arr, i, pivot-1);                   
            //递归排序右子数组  
            qsort(arr, pivot+1, j);                  
        }  
    }  
    //划分  
    private static int partition(int[] arr, int i, int i){  
        int pivot = arr[arr.length-1];    
        int i=0;  
        if(int j=0;j<arr.length-2;j++){  
            if(arr[j]<pivot){  
                swap(arr[i],arr[j])  
            }  
        }  
        //扫描完成，基准数据到位  
        swap(arr[i],arr[arr.length-1])  
        //返回的是基准数据的位置  
        return i;  
    }  ` ` `
 
* 性能分析  
    
    * 执行效率
        * 最差情况O(n^2) 
        * 最好情况O(n(logn))
        * 平均情况O(n(logn))
    * 内存消耗
        * O(n)
    * 稳定性  
        * 不稳定
        * 因为排序结束后，基准数据与A[i]进行了替换


## (总结)冒泡&&插入&&选择的区别
